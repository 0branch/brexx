{\rtf1\ansi\ansicpg1252\uc1 \deff1\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;
\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet{\nowidctlpar\adjustright \f1 \snext0 Normal;}{\s1\nowidctlpar\adjustright \f1 \sbasedon0 \snext0 heading 1;}{\s2\keepn\nowidctlpar\outlinelevel1\adjustright \b\f1\fs20 \sbasedon0 \snext0 heading 2;}{
\s3\keepn\nowidctlpar\outlinelevel2\adjustright \i\f1\fs20 \sbasedon0 \snext0 heading 3;}{\s4\keepn\nowidctlpar\outlinelevel3\adjustright \b\i\f1\fs20 \sbasedon0 \snext0 heading 4;}{\s5\keepn\nowidctlpar\outlinelevel4\adjustright \b\f1\fs20\cf2 
\sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}{\s15\nowidctlpar\adjustright \f1\fs20 \sbasedon0 \snext15 Body Text;}{\s16\nowidctlpar\adjustright \b\f1\fs20 \sbasedon0 \snext16 Body Text 2;}{\*\cs17 \additive \ul\cf2 
\sbasedon10 Hyperlink;}}{\*\listtable{\list\listtemplateid67698689\listsimple{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname 
;}\listid26222844}{\list\listtemplateid67698703\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\fi-360\li360\jclisttab\tx360 }{\listname ;}\listid387653523}
{\list\listtemplateid412756726\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat4\levelspace0\levelindent0{\leveltext\'01\'00;}{\levelnumbers\'01;}\fbias0 \fi-360\li660\jclisttab\tx660 }{\listname ;}\listid642125344}
{\list\listtemplateid685034422\listsimple{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat0\levelspace0\levelindent0{\leveltext\'01\u-3880 ?;}{\levelnumbers;}\f14\fbias0 \fi-360\li645\jclisttab\tx645 }{\listname ;}\listid817649619}
{\list\listtemplateid-2043647128\listsimple{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat4\levelspace0\levelindent0{\leveltext\'01-;}{\levelnumbers;}\f0\fbias0 \fi-360\li1080\jclisttab\tx1080 }{\listname ;}\listid1179394615}
{\list\listtemplateid100933540\listsimple{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat0\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 \fi-405\li705\jclisttab\tx705 }{\listname ;}\listid1461148020}
{\list\listtemplateid1308904932\listsimple{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat0\levelspace0\levelindent0{\leveltext\'01-;}{\levelnumbers;}\f0\fbias0 \fi-390\li690\jclisttab\tx690 }{\listname ;}\listid1521704600}
{\list\listtemplateid67698703\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid1536040180}
{\list\listtemplateid67698689\listsimple{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid1571503040}
{\list\listtemplateid67698703\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid1700280298}
{\list\listtemplateid67698703\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'02\'00.;}{\levelnumbers\'01;}\fi-360\li360\jclisttab\tx360 }{\listname ;}\listid1977485913}
{\list\listtemplateid-379297298\listsimple{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat15\levelspace0\levelindent0{\leveltext\'01-;}{\levelnumbers;}\f0\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid2004819315}
{\list\listtemplateid67698689\listsimple{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 \fi-360\li360\jclisttab\tx360 }{\listname ;}\listid2129011526}}
{\*\listoverridetable{\listoverride\listid1521704600\listoverridecount0\ls1}{\listoverride\listid1461148020\listoverridecount0\ls2}{\listoverride\listid642125344\listoverridecount0\ls3}{\listoverride\listid817649619\listoverridecount0\ls4}
{\listoverride\listid2004819315\listoverridecount0\ls5}{\listoverride\listid1977485913\listoverridecount0\ls6}{\listoverride\listid1536040180\listoverridecount0\ls7}{\listoverride\listid1700280298\listoverridecount0\ls8}{\listoverride\listid1179394615
\listoverridecount0\ls9}{\listoverride\listid387653523\listoverridecount0\ls10}{\listoverride\listid2129011526\listoverridecount0\ls11}{\listoverride\listid1571503040\listoverridecount0\ls12}{\listoverride\listid26222844\listoverridecount0\ls13}}{\info
{\author    }{\operator    }{\creatim\yr2004\mo3\dy23\hr9\min44}{\revtim\yr2004\mo6\dy3\hr20\min56}{\version149}{\edmins1929}{\nofpages15}{\nofwords4682}{\nofchars26689}{\*\company ABC}{\nofcharsws32775}{\vern89}}
\widowctrl\ftnbj\aenddoc\hyphcaps0\viewkind4\viewscale80 \fet0\sectd \linex0\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3
\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}
{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain 
\s1\keepn\nowidctlpar\outlinelevel0\adjustright \f1 {\b\fs20 Chapter 21 --   BRexx -- Program Examples
\par }\pard\plain \nowidctlpar\adjustright \f1 {
\par 
\par }\pard\plain \s1\keepn\nowidctlpar\outlinelevel0\adjustright \f1 {\b\fs20 Introduction
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20 
\par This chapter provides examples of some of the unique features of BRexx.  BRexx meets the TLR-2 standards and is at language level 4.00.  The goal of this chapter is to demonstrate BRexx features tha
t go beyond the language standard and are specific to this Rexx implementation.
\par 
\par 
\par }\pard\plain \s2\keepn\nowidctlpar\outlinelevel1\adjustright \b\f1\fs20 {Example \endash  C-like I/O}{\b0 
\par 
\par BRexx supports both standard Rexx I/O functions and a C-language inspired I/O model.
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20 
\par }\pard\plain \s15\nowidctlpar\adjustright \f1\fs20 {This program is similar to the I/O example program of Chapter 19 o
n Rexx/imc.  It illustrates the C I/O model and its functions.  The script simply copies one file to another.   The source and target files are specified on the command line when running the program.
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20 
\par Here is the script:
\par 
\par }{\b\fs20    /******************************************************************************/
\par    /* FCOPY BREXX                                                                               */
\par    /*                                                                                                          */
\par    /* Uses BRexx I/O functions to copy a file.                                     */
\par    /******************************************************************************/
\par    parse arg source target        /* get file names, retain lower-case  */
\par 
\par    /* open input & output files, establish file Handles                       */
\par  
\par    in_hnd  = open(source,'r')                /* open input file                     */
\par    out_hnd = open(target,'w')               /* open output file                  */
\par    if in_hnd = -1 | out_hnd = -1 then     /* check for errors on open   */
\par       say 'File OPEN Error!'
\par 
\par    /* perform the file copy                                                                       */
\par 
\par    line = read(in_hnd)
\par    do while eof(in_hnd) = 0
\par       bytes_written = write(out_hnd,line,newline)
\par       line = read(in_hnd)
\par    end
\par }{\fs20 
\par }{\b\fs20    /* close the files and exit                                                                    */
\par 
\par    rc_in  = close(in_hnd)                     /* close input file                       */
\par    rc_out = close(out_hnd)                 /* close output file                     */
\par    if rc_in <> 0 | rc_out <> 0 then       /* check for errors on close      */
\par       say 'File CLOSE Error!'
\par 
\par    exit 0
\par }{\fs20 
\par 
\par In the script, these lines open the input and output files and check for errors:
\par 
\par }{\b\fs20    in_hnd  = open(source,'r')                /* open input file                     */
\par    out_hnd = open(target,'w')               /* open output file                  */
\par    if in_hnd = -1 | out_hnd = -1 then     /* check for errors on open   */
\par       say 'File OPEN Error!'
\par }{\fs20 
\par }\pard\plain \s2\keepn\nowidctlpar\outlinelevel1\adjustright \b\f1\fs20 {\b0 The }{open}{\b0  function follows C-language protocol for the }{\b0\i mode}{\b0 , or the manner in which the file will be used::
\par }\pard\plain \nowidctlpar\adjustright \f1 {
\par }{\fs20 \tab r \tab read\tab 
\par \tab w\tab write\tab \tab (overwrites any existing file)
\par \tab a\tab append\tab \tab (appends to the end of any existing file)
\par \tab +\tab read and write
\par }\pard \fi720\nowidctlpar\adjustright {\fs20 t\tab text-mode
\par }\pard \nowidctlpar\adjustright {\fs20 \tab b\tab binary-mode
\par 
\par The function returns a }{\i\fs20 file handle}{\fs20  that can be referred to in subsequent file operations.  If the function returns }{\b\fs20 \endash 1}{\fs20 , an error occurred during the }{\b\fs20 open}{\fs20  function.
\par }\pard\plain \s2\keepn\nowidctlpar\outlinelevel1\adjustright \b\f1\fs20 {  
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20 The }{\b\fs20 do while}{\fs20  group uses the }{\b\fs20 read}{\fs20  function to read the input file.  }{\b\fs20 read}{\fs20  returns either a specific number of characters or line(s).  It also operates }{
\i\fs20 on an entire file}{\fs20  by using the \ldblquote }{\b\fs20 F}{\fs20 \rdblquote  parameter.  In fact, we could have copied the entire file with one line of code instead of the }{\b\fs20 do-while}{\fs20  loop:
\par 
\par      }{\b\fs20 call  write  \ldblquote new_file\rdblquote  ,  read(\ldblquote old_file\rdblquote ,\rdblquote F\rdblquote )    /* copy entire file ! */
\par }{\fs20 
\par The }{\b\fs20 eof}{\fs20  function returns }{\b\fs20 1 }{\fs20 at the end of file, or }{\b\fs20 0}{\fs20  if the file is open and there are still lines to read.  As with the }{\b\fs20 read}{\fs20  and }{\b\fs20 write}{\fs20  functions, it t
akes the file handle returned from the }{\b\fs20 open}{\fs20  function as a parameter:
\par 
\par }{\b\fs20      do while eof(in_hnd) = 0}{\fs20 
\par 
\par The }{\b\fs20 write}{\fs20  function writes a line to the given file handle, optionally followed by a newline or linefeed character(s).  It returns the number of bytes written:
\par 
\par }{\b\fs20       bytes_written = write(out_hnd,line,newline)
\par }{\fs20 
\par The }{\b\fs20 read}{\fs20  function does not provide the line-end character(s) to the script, so the script must add the newline to the output string through the }{\b\fs20 write}{\fs20  function }{\b\fs20 newline}{\fs20  parameter.
\par 
\par This code concludes the program.  It closes both files based on their file handles, and checks for an error during closing.  The return code of }{\b\fs20 0}{\fs20  means the files closed correctly:
\par 
\par }{\b\fs20    rc_in  = close(in_hnd)                     /* close input file                       */
\par    rc_out = close(out_hnd)                 /* close output file                     */
\par    if rc_in <> 0 | rc_out <> 0 then       /* check for errors on close      */
\par       say 'File CLOSE Error!'
\par }{\fs20 
\par The C-like I/O model is powerful.  The ability to work with files in binary mode simply by coding the }{\b\fs20 b}{\fs20  option on the }{\b\fs20 open}{\fs20 
 function is especially useful.  This allows byte-by-byte file processing regardless of the manner in which the operating system separates lines or marks the end of file.
\par 
\par These file functions are a
ll built-in.  BRexx also provides an external function library for Unix and DOS that can, among other features, read or write an entire file to/from an array.   BRexx also offers an interface to MySQL as a set of built-in functions.
\par 
\par 
\par }\pard\plain \s2\keepn\nowidctlpar\outlinelevel1\adjustright \b\f1\fs20 {Example \endash  ANSI Screen I/O with Random Data Access
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20 
\par This example illustrates the American National Standards Institute (ANSI) standard commands for controlling a display screen.   Using ANSI functions allows you to create portable programs with character-based, full-screen I/O.
   ANSI terminal emulation does not support graphical user interfaces or GUIs.
\par 
\par The program shows another use for BRexx\rquote s C-like I/O.  In this case, these functions create a }{\i\fs20 direct-access}{\fs20  (or }{\i\fs20 random-access}{\fs20 ) file.   This script writes records into that file
.  A separate script  directly retrieves specified records from that file and displays them to the user.
\par 
\par The purpose of this script is to assign swimming pool passes to local pool patrons.   The user enters each patron\rquote s first and last name and their phone number.  The script writes the patron information to the output file.  The patron\rquote 
s Pool Pass Number is their relative record number within the output file.  In other words, the first patron written to the file is implicitly assigned Pool Pass Number 1, the second person is assigned Pool Pass Number 2, and so on.    
\par 
\par Here\rquote s how the script works.  First it clears the screen, then it displays a data entry form similar to that depicted in figure 21-1.  The user fills in each data item, and presses the <ENTE
R> key for the cursor to skip to the next data entry position in the form.  After the user enters the last data element on the form (the person\rquote s phone number), the script writes his or her record to the output file.
\par 
\par The script repeatedly displays the data entry form to collect information until the user enters \lquote }{\b\fs20 exit\rquote }{\fs20  into the first data entry position on the form (as the pool patron\rquote 
s last name).  The script closes the output file and terminates.
\par 
\par Figure 21-2 shows what the data entry form might look like after the user enters information.
\par 
\par }\pard\plain \s15\nowidctlpar\adjustright \f1\fs20 {Here\rquote s the data entry script:
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20 
\par 
\par }{\b\fs20    /************************************************************************************/
\par    /* POOLPASS                                                                                             */
\par    /*                                                                                                                  */
\par    /* Uses ANSI I/O to get Pool Pass info & build a random-access file  */
\par    /***********************************************************************************/
\par 
\par    call AnsiColor 'LIGHTCYAN','BLUE'    /* set screen colors                  */
\par 
\par    recsize = 30                                           /* length of each output record*/
\par    out_hnd = open('poolfile','ab')             /* append to binary output file */ 
\par 
\par    do while first_name <> 'exit' 
\par 
\par        /* Clear the screen and write the screen title                                     */
\par 
\par        call AnsiCls
\par        call AnsiGoto 30,1
\par        call charout ,'Pool Pass System'
\par 
\par       /* Draw the form to gather first and last names, and phone number */
\par 
\par       call AnsiGoto 1,10   ;   call charout ,"First Name: __________"
\par       call AnsiGoto 1,11   ;   call charout ,"Last Name : __________"
\par       call AnsiGoto 1,13   ;   call charout ,"Phone Number: ___-____"
\par }{\fs20 
\par       }{\b\fs20 /* Read the information the user entered on the form                         */
\par                     
\par       call AnsiGoto 13,10     ;   parse pull first_name   . 
\par    
\par       if first_name <> 'exit' then do                      /* quit if user enters 'exit' */
\par 
\par          call AnsiGoto 13,11  ;   parse pull last_name    .
\par          call AnsiGoto 15,13  ;   parse pull phone_number .
\par 
\par          /* Build an output record, write user info to POOLPASS file            */
\par  
\par          outstr = first_name || ',' || last_name || ',' || phone_number
\par          outstr = left(outstr,recsize,' ')                   /* ensure 30-byte record   */
\par          call write out_hnd,outstr                           /* write the output record */
\par       end
\par    end
\par 
\par    call close out_hnd                                         /* close pool pass file        */
\par    call AnsiColor 'WHITE','BLACK'                   /* set screen colors back  */
\par    call AnsiCls                                                    /* clear screen                    */        
\par    exit 0
\par }{\fs20 
\par 
\par The first line in the script sets the foreground and background screen colors by calling the }{\b\fs20 ansicolor}{\fs20  function:
\par 
\par }{\b\fs20      call AnsiColor 'LIGHTCYAN','BLUE'             /* set screen colors         */
\par }{\fs20 
\par Since Rexx is a case-insensitive language, }{\b\fs20 ansicolor}{\fs20  is the same as }{\b\fs20 AnsiColor}{\fs20 
.  Code the function in whichever way you prefer.  In this case, we use bright light cyan letters on a blue background.  The entire form (screen) will be dark blue over-written with cyan messages.
\par 
\par The next line opens the output file to which pool pass information is written.  Since the file is used as a direct-access file, it is opened in }{\i\fs20 binary mode}{\fs20  (indicated by the }{\b\fs20 b}{\fs20 
 option).  No line-termination characters will be written to the file.   The option }{\b\fs20 a}{\fs20  stands for }{\b\fs20 append}{\fs20 
.  Every time this program runs it will append new data to the end of the file.  The first time the script runs, the file will not exist, so the }{\b\fs20 a}{\fs20  option creates it:
\par 
\par }{\b\fs20       out_hnd = open('poolfile','ab')                      /* open binary output file*/ 
\par 
\par }{\fs20 As in the prior example program, the }{\i\fs20 output handle}{\fs20  (here called }{\b\fs20 out_hnd}{\fs20 ) will be referred to in subsequent }{\b\fs20 read}{\fs20 , }{\b\fs20 write}{\fs20  and }{\b\fs20 close}{\fs20  file functions.
\par 
\par These lines clear the screen by the }{\b\fs20 ansicls}{\fs20  function.  They position the cursor to line 1, column 30 by the }{\b\fs20 ansigoto}{\fs20  function, then write the screen title at that position:
\par 
\par }{\b\fs20        call AnsiCls
\par        call AnsiGoto 30,1
\par        call charout ,'Pool Pass System'
\par }{\fs20 
\par These lines invoke the }{\b\fs20 ansigoto}{\fs20  function to position the cursor and write lines to the display.  The result is a full-screen data entry form:
\par 
\par }{\b\fs20        call AnsiGoto 1,10   ;   call charout ,"First Name: __________"
\par        call AnsiGoto 1,11   ;   call charout ,"Last Name : __________"
\par        call AnsiGoto 1,13   ;   call charout ,"Phone Number: ___-____"
\par }{\fs20 
\par Position the cursor back to the first data entry position, so that the user can enter the }{\b\fs20 First Name}{\fs20 :
\par 
\par }{\b\fs20       call AnsiGoto 13,10     ;   parse pull first_name   . 
\par }{\fs20 
\par }\pard\plain \s15\nowidctlpar\adjustright \f1\fs20 {If the user does not enter \lquote }{\b exit\rquote }{, continue collecting the other form information:
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20 
\par }{\b\fs20       call AnsiGoto 13,11  ;   parse pull last_name    .
\par       call AnsiGoto 15,13  ;   parse pull phone_number .
\par 
\par }{\fs20 Now that the script has all the input information, concatenate it into an output record.  Use the }{\b\fs20 left}{\fs20  function to ensure that output record is padded with blanks to the }{\i\fs20 record length}{\fs20 
, the length of each record that is written to the output file.   (The record length was set to 30 characters in the variable }{\b\fs20 recsize}{\fs20  at the start of the program.)   Write the binary
 output record without any newline or end-of-line characters:
\par 
\par }{\b\fs20        outstr = first_name || ',' || last_name || ',' || phone_number
\par        outstr = left(outstr,recsize,' ')                /* ensure 30-byte record     */
\par        call write out_hnd,outstr                       /* write the output record    */
\par }{\fs20 
\par The program continues to display the data entry form, collect user information, assign pool pass numbers, and write records to the file.   After the user enters \lquote }{\b\fs20 exit\rquote }{\fs20 , the program closes the output fil
e, re-sets the screen colors back to their usual setting, and clears the screen to terminate:
\par 
\par }{\b\fs20      call close out_hnd                                       /* close pool pass file         */
\par      call AnsiColor 'WHITE','BLACK'                /* set screen colors back    */
\par      call AnsiCls                                                 /* clear screen                      */}{\fs20 
\par 
\par At the end of this script, the file named }{\b\fs20 poolfile }{\fs20 contains a number of 30-byte records, one per pool patron.   The }{\i\fs20 relative record number}{\fs20 
 of each record represents its implicitly assigned Pool Pass Number.   There are no linefeeds between records.  Since each record is padded with blanks to make a 30-byte record, the file might look like this:
\par 
\par }{\b\fs20      Monica,Geller,476-4243        Ross,Geller,476-1749}{\fs20        \'85etc\'85
\par }{\b\fs20 
\par }\pard\plain \s15\nowidctlpar\adjustright \f1\fs20 {This script is a limited demo program.  It does not error-check the user input or inspect return codes for I/O functions, as a \ldblquote production\rdblquote  program would.
\par }\pard\plain \nowidctlpar\adjustright \f1 {\b\fs20 
\par }\pard\plain \s15\nowidctlpar\adjustright \f1\fs20 {BRexx offers ANSI terminal emulation as built-in functions for Window
s and 32-bit DOS.   The built-in functions are faster than external functions.  The example scripts in this chapter all ran under Windows.   
\par 
\par For some operating systems, you will need to use BRexx\rquote s external function library, called }{\b ansi.r}{, to support ANS
I terminal emulation.  In this case, encode this line at the top of the script to load the ANSI external functions prior to invoking them:
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20 
\par }{\b\fs20      load  \ldblquote ansi.r\rdblquote         /* load all external ANSI terminal functions for use */
\par }{\fs20 
\par You will also need to ensure your operating system uses the file }{\b\fs20 ansi.sys}{\fs20 .  For example, under Windows or DOS, code a line in the }{\b\fs20 config.sys}{\fs20  file to reference the }{\b\fs20 ansi.sys}{\fs20  file.  The }{\b\fs20 
config.sys}{\fs20  file resides in the root directory, }{\b\fs20 c:\\}{\fs20  .  Depending on where the file }{\b\fs20 ansi.sys}{\fs20  resides on your system, you would code one of the following in the }{\b\fs20 config.sys}{\fs20  file:
\par 
\par \tab Windows XP\tab \tab \tab device=c:\\windows\\system32\\ansi.sys
\par \tab Windows NT, 2000, 2003\tab device=c:\\dos\\ansi.sys
\par \tab Windows 95, 98, 98SE, ME\tab device=c:\\windows\\command\\ansi.sys
\par \tab All versions of DOS\tab \tab device=c:\\dos\\ansi.sys
\par 
\par Typically, one re-boots the machine to execute the }{\b\fs20 config.sys}{\fs20  file and pick up the new information on  the }{\b\fs20 ansi.sys}{\fs20  driver.
\par 
\par 
\par }\pard\plain \s2\keepn\nowidctlpar\outlinelevel1\adjustright \b\f1\fs20 {Example \endash  Direct Data Access
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20 
\par The }{\b\fs20 Pool Pass}{\fs20  program created a file of 30-byte records, each having information on a swimming pool member.   
\par 
\par This script prompts the user to enter a Pool Pass Number, then displays that patron\rquote s record on the screen.  This sample interaction with the }{\b\fs20 Pool Read}{\fs20  program shows that the second record (Pool Pass Number 2) is assigned to 
Ross Geller, and Pool Pass Number 4 is assigned to Joey Tribiani.  Pool Pass Number 17 is not yet assigned, as that relative record does not exist in the file.  Pool Pass Numbers correspond to direct access positions or }{\i\fs20 slots}{\fs20 
  within the random-access file:
\par 
\par      }{\b\fs20 c:\\brexx32\\pgms> rexx32 poolread.r
\par      
\par      Enter Pool Pass Number: 2
\par 
\par      Pass Number:  2
\par      Person           :  Ross Geller
\par      Phone            :  476-1749
\par 
\par      Enter Pool Pass Number:  4
\par 
\par      Pass Number:  4
\par      Person           :  Joey Tribiani
\par      Phone            :  476-9876
\par 
\par      Enter Pool Pass Number: 17
\par      That Pool Pass number is not assigned.
\par 
\par }\pard\plain \s2\keepn\nowidctlpar\outlinelevel1\adjustright \b\f1\fs20 {     Enter Pool Pass Number: exit
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20 
\par 
\par }\pard\plain \s15\nowidctlpar\adjustright \f1\fs20 {This script illustrates direct or random access to the pool pass records:
\par }\pard\plain \nowidctlpar\adjustright \f1 {\b\fs20 
\par    /********************************************************************************/
\par    /* POOLREAD                                                                                        */
\par    /*                                                                                                             */
\par    /* Reads random-access pool file records to display to the user.   */
\par    /********************************************************************************/
\par 
\par    in_hnd = open('poolfile','rb')                      /* open binary input file */ 
\par 
\par    recsize = 30                                                 /* size of 1 file record     */ 
\par    filesize = seek(in_hnd,0,"EOF")                /* returns file size           */
\par    input_limit = filesize - recsize                   /* calculate last record   */
\par 
\par    say ' '
\par    call charout ,"Enter Pool Pass Number: "    /* get the user's request */
\par    pull pass_number .
\par 
\par    do while pass_number <> 'EXIT'
\par 
\par       position = ((pass_number-1) * recsize)  /* read record at POSITION */
\par 
\par       if position > input_limit                           /* POSITION > last record    */
\par          then say 'That Pool Pass number is not assigned.'
\par 
\par       else do 
\par          call seek in_hnd,position                    /* position to the record       */
\par          in_record = read(in_hnd,recsize)       /* read user's pool record     */
\par 
\par          sep = ','                                                  /* parse & display record     */
\par          parse value in_record with first_name (sep) ,
\par                     last_name (sep) phone_number     
\par          say ' '
\par          say 'Pass Number:' pass_number         
\par          say 'Person     :' first_name last_name          /* display the record */
\par          say 'Phone      :' phone_number     
\par       end
\par 
\par       say ' '
\par       call charout ,"Enter Pool Pass Number: "        /* get user's request */
\par       pull pass_number .
\par   end
\par 
\par   call close in_hnd
\par   exit 0
\par 
\par 
\par }{\fs20 The script opens the file for read access ( }{\b\fs20 r}{\fs20  ) and in binary mode ( }{\b\fs20 b}{\fs20  ).  Binary mode is appropriate because there are no line-termination characters within the file:
\par }{\b\fs20 
\par      in_hnd = open('poolfile','rb')                      /* open binary input file */ 
\par 
\par }{\fs20 This code uses the }{\b\fs20 seek}{\fs20  function to return the size of the file.  The }{\b\fs20 EOF}{\fs20  parameter forces the file pointer to the end of file.  The calculation for }{\b\fs20 input_limit}{\fs20 
 is used to tell if the user has entered a Pool Pass Number that does not yet exist (that is larger than the file size indicates has been stored):
\par 
\par }{\b\fs20    recsize = 30                                                 /* size of 1 file record     */ 
\par    filesize = seek(in_hnd,0,"EOF")                /* returns file size           */
\par    input_limit = filesize - recsize                   /* calculate last record   */
\par }{\fs20 
\par The script prompts the user to enter a Pool Pass Number.  This code takes that }{\b\fs20 pass_number}{\fs20  and calculates the relative byte position where the record is located within the direct access file:
\par 
\par }{\b\fs20      position = ((pass_number-1) * recsize)  /* read record at POSITION */
\par 
\par }{\fs20 If the }{\b\fs20 position}{\fs20  is too big, we know there is no such record and tell the user so:
\par }{\b\fs20 
\par       if position > input_limit                           /* POSITION > last record    */
\par          then say 'That Pool Pass number is not assigned.'
\par 
\par }\pard\plain \s15\nowidctlpar\adjustright \f1\fs20 {If the Pool Pass Number is valid, the script uses the }{\b seek}{ function to position the file position pointer to read the proper record.  Then the script reads that 30-byte record:
\par }\pard\plain \nowidctlpar\adjustright \f1 {\b\fs20  
\par          call seek in_hnd,position                    /* position to the record       */
\par          in_record = read(in_hnd,recsize)       /* read user's pool record     */
\par }{\fs20 
\par The }{\b\fs20 parse}{\fs20  instruction parses the record into its components, as separated by commas:
\par 
\par }{\b\fs20          sep = ','                                                  /* parse & display record     */
\par          parse value in_record with first_name (sep) ,
\par                     last_name (sep) phone_number     
\par 
\par }{\fs20 Now the script displays the Pool Pass information on the screen.  Then it prompts the user to input another Pool Pass Number.  When the user enters \lquote }{\b\fs20 exit\rquote }{\fs20 , the script terminates.
\par 
\par This script demonstrates how to use BRexx\rquote s C-like I/O functions to open a direct-access file and randomly retrieve records. 
\par 
\par 
\par }\pard\plain \s2\keepn\nowidctlpar\outlinelevel1\adjustright \b\f1\fs20 {Example \endash  DOS Functions
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20 
\par A DOS program!!   Who cares about DOS?
\par 
\par While desktop computer users long ago moved from DOS to Windows, DOS 
continues to be one of the most widely-used operating systems in the world.   Many applications require a completely stable, well-known operating system with a very small footprint.  Examples include embedded systems and device control programming.   Thes
e software on these systems must run forever without maintenance.  DOS fits the bill \endash 
 it is so well-known that even its quirks and bugs are documented.  And with many free versions available, DOS keeps prices down, an important factor when programming cons
umer devices that sell in such large numbers that even a small fee becomes an important cost factor.
\par 
\par This simple script shows some of BRexx\rquote s DOS-specific functions.  These functions:
\par 
\par {\pntext\pard\plain\f1\fs20 \hich\af1\dbch\af0\loch\f1 1.\tab}}\pard \fi-360\li720\nowidctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls10\adjustright {\fs20 
Retrieve information about the PC on which the script runs
\par {\pntext\pard\plain\f1\fs20 \hich\af1\dbch\af0\loch\f1 2.\tab}}\pard \fi-360\li720\nowidctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls10\adjustright {\fs20 Read in a file name from the user and:

\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \fi-360\li1080\nowidctlpar\jclisttab\tx1080{\*\pn \pnlvlblt\ilvl0\ls11\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls11\adjustright {\fs20 Display the file\rquote 
s size and attributes
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \fi-360\li1080\nowidctlpar\jclisttab\tx1080{\*\pn \pnlvlblt\ilvl0\ls12\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls12\adjustright {\fs20 
Read the entire file into an array in one statement
\par {\pntext\pard\plain\f3\fs20 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \fi-360\li1080\nowidctlpar\jclisttab\tx1080{\*\pn \pnlvlblt\ilvl0\ls13\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls13\adjustright {\fs20 Display the file\rquote 
s contents by writing out the array
\par }\pard \nowidctlpar\adjustright {\fs20        3.   Issue an operating system command by a number of different methods
\par 
\par Here\rquote s the script output.  (We have removed extraneous blank lines from the output for readability).
\par 
\par }{\b\fs20      ============= PC Information =============
\par      The machine name is : Not defined
\par      The DOS version is    : 6.20
\par      System memory is     : 201504
\par      The current disk is     : C
\par      Freespace on drives  : 112246784  211787776
\par      Enter a file name: dos_info.txt\tab \tab }{\i\fs20 <= The user entered the file name at this prompt             
\par }{\b\fs20      ============= File Information =============
\par      The filesize of the test file is: 48
\par      The file attributes of test file: RHSVDA
\par      Here is the contents of file: DOS_INFO.TXT
\par      this is line 1
\par      this is line 2
\par      this is line 3
\par      =========== DOS Command Tests ===========
\par      Method 1- DOS version is:
\par      MS-DOS Version 6.20
\par      Method 2- DOS version is:
\par      MS-DOS Version 6.20
\par      Method 3- DOS version is:
\par      MS-DOS Version 6.20
\par      Methods 4 and 5- DOS version is:
\par      MS-DOS Version 6.20
\par      MS-DOS Version 6.20
\par }{\fs20 
\par Here is the program:
\par 
\par }{\b\fs20 
\par     /**********************************************************************/
\par     /* DOS INFO                                                                             */
\par     /*                                                                                               */
\par     /* Illustrates some DOS-specific functions of BRexx.         */
\par     /**********************************************************************/
\par     call load "dos.r"               /* load the DOS function library  */
\par     call load "files.r"             /* load the FILES function library */
\par 
\par    /* Display some PC system information                                */
\par 
\par    say '============= PC Information ==============='
\par    say 'The machine name is :'   machinename()
\par    say 'The DOS version is    :'   dosversion()
\par    say 'System memory is     :'   storage()
\par    say 'The current disk is     :'   getcurdisk()
\par    say 'Freespace on drives  :'   drivespace()
\par 
\par    call charout ,'Enter a file name: '   /* get a file name from user*/    
\par    pull testfile .                                              
\par 
\par    if exist(testfile) then do                  /* if the input file exists...    */
\par   
\par         /* display file size and its attributes as a string                   */
\par 
\par        say '============= File Information ============='
\par }{\fs20        }{\b\fs20 say 'The filesize of the test file is:'  filesize(testfile)
\par        file_attr = fileattr(testfile)
\par        say 'The file attributes of test file:'  attr2str(file_attr)
\par 
\par        /* read the entire file in 1 statement into an array, display it */
\par 
\par        call readstem testfile,"filein."    /* read entire file into array */
\par        say 'Here is the contents of file:' testfile
\par        do j = 1 to filein.0                        /* item 0 tells # in the array */
\par            say filein.j
\par        end
\par        end  /* if... then do */
\par 
\par    else
\par        say 'File does not exist:' testfile
\par 
\par     /* issue the DOS version (VER) command by many different techniques */
\par 
\par     say '=========== DOS Command Tests =============='
\par 
\par     call charout ,'Method 1- DOS version is:'  /* the traditional method  */  
\par     'ver'
\par 
\par     version = 'ver'()                                     /* capture "function" output    */
\par     call charout ,('Method 2- DOS version is:' || version) 
\par 
\par     say 'Method 3- DOS version is:'
\par     'ver (STACK'                                         /* capture output via the Stack */
\par     do while ( queued() > 0 )
\par        parse pull version
\par        say version
\par     end
\par                                                           /* use ADDRESS to issue command */
\par     call charout ,'Methods 4 and 5- DOS version is:'
\par     address SYSTEM  ver
\par     address COMMAND ver
\par     exit 0
\par 
\par 
\par }\pard\plain \s15\nowidctlpar\adjustright \f1\fs20 {The first statements in this program give the program access to all the functions in the two external function libraries in the files named }{\b DOS.R}{ and }{\b FILES.R }{:
\par }\pard\plain \nowidctlpar\adjustright \f1 {\b\fs20 
\par     call load "dos.r"              /* load the DOS function library   */
\par     call load "files.r"             /* load the FILES function library */
\par 
\par }{\fs20 Loading the entire function library in one command is much more convenient than the SAA functions that load only one function per instruction.
\par 
\par Now the script issues a series of functions to retrieve and display information about the machine on which it runs}{\b\fs20 :
\par 
\par    say 'The machine name is :'   machinename()
\par    say 'The DOS version is    :'   dosversion()
\par    say 'System memory is     :'   storage()
\par    say 'The current disk is     :'   getcurdisk()
\par    say 'Freespace on drives  :'   drivespace()
\par 
\par }\pard\plain \s15\nowidctlpar\adjustright \f1\fs20 {The }{\b storage}{ function is particularly interesting.  Without any operand, as above, it displays the total amoun
t of machine memory.   It can also be coded to display the memory contents at a specific location.  For example, this function displays }{\b 100}{ bytes of memory at machine location }{\b 500}{:
\par 
\par      }{\b say  storage(500,100)     
\par }{
\par The function can also be used to change that memory.  This changes five bytes of memory starting at decimal location }{\b 500}{:
\par 
\par }{\b      say  storage(500,5,\rquote aaaaa\rquote )
\par }{
\par Next the script prompts for the user to enter a file name.  This code tests whether the file exists:
\par 
\par }\pard\plain \nowidctlpar\adjustright \f1 {\b\fs20      if exist(testfile) then do                  /* if the input file exists...    */
\par }\pard\plain \s15\nowidctlpar\adjustright \f1\fs20 {
\par Assuming it does, the script uses BRexx functions to display its size and attributes:
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20 
\par }{\b\fs20        say 'The filesize of the test file is:'  filesize(testfile)
\par        file_attr = fileattr(testfile)
\par        say 'The file attributes of test file:'  attr2str(file_attr)
\par }{\fs20 
\par The }{\b\fs20 fileattr}{\fs20  function retrieves the file\rquote s attributes, and the }{\b\fs20 attr2str}{\fs20  function converts them to a displayable character string.
\par 
\par The script reads the entire file into an array by this one statement:
\par 
\par }{\b\fs20       call readstem testfile,"filein."    /* read entire file into array */
\par }{\fs20 
\par and displays the contents of the file by reading through the array:
\par 
\par }{\b\fs20        do j = 1 to filein.0                        /* item 0 tells # in the array */
\par            say filein.j
\par        end
\par }{\fs20 
\par The zero-th item in the array ( }{\b\fs20 filein.0}{\fs20  ) tells how many elements the }{\b\fs20 readstem}{\fs20  function placed into the array.  The }{\b\fs20 writestem}{\fs20  function writes an entire array in a single statement.  The element }{
\b\fs20 stem.0}{\fs20  tells }{\b\fs20 writestem}{\fs20  how many lines to write.
\par 
\par Finally, the program demonstrates several different ways to issue operating system commands from within BRexx scripts.  In this case, the program issues the DOS }{\b\fs20 ver}{\fs20  ( }{\b\fs20 version}{\fs20  ) command.
\par 
\par First the script issues this operating system command in the traditional fashion:
\par 
\par }{\b\fs20      'ver'
\par }{\fs20 
\par The interpreter does not recognize this command, and so it sends it to the external environment for execution.  In this case, of course, the default environment for command execution is the operating system.
\par 
\par }\pard\plain \s15\nowidctlpar\adjustright \f1\fs20 {Next the script treats the OS command as if it were a function and captures and displays its output.  This technique works only if the command uses standard I/O:
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20 
\par }{\b\fs20      version = 'ver'()                                     /* capture "function" output    */
\par      call charout ,('Method 2- DOS version is:' || version) 
\par }{\fs20 
\par Now the script issues the command again and captures its output into the stack:
\par 
\par }{\b\fs20      'ver (STACK'                                         /* capture output via the Stack */
\par }{\fs20 
\par To retrieve the results, just }{\b\fs20 pull}{\fs20  or }{\b\fs20 parse pull}{\fs20  the stack items.  The }{\b\fs20 queued}{\fs20  function tells how many lines are on the stack.  
\par 
\par Lastly, the script issues the }{\b\fs20 ver}{\fs20  command by the }{\b\fs20 address}{\fs20  instruction.  First it targets the }{\b\fs20 SYSTEM}{\fs20  environment for command execution, then the }{\b\fs20 COMMAND}{\fs20  environment:
\par 
\par }{\b\fs20     address SYSTEM  ver
\par     address COMMAND ver
\par }{\fs20 
\par While this script demonstrates a small number of the BRexx external functions, it suggests how useful they can be for OS-specific programming.  The functions are easy to use and the documentation clearly and succinctly describes how to code them.  
\par 
\par }{\b\fs20 
\par Summary
\par 
\par }\pard\plain \s15\nowidctlpar\adjustright \f1\fs20 {This chapter demonstrates some of the unique features of BRexx.  While BRexx meets the TLR-2 standards, these additional functions give it the features developers often find useful.  
\par 
\par The functions we demonstrate included C-like I/O functions, the ANSI terminal emulation package for portable full-screen I/O, and direct record access through I/O functions.  The last example program ran under DOS and demonstrates
 a few of the DOS-specific functions in the product.
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20 
\par }{\b\fs20 \page 
\par }\pard\plain \s4\keepn\nowidctlpar\outlinelevel3\adjustright \b\i\f1\fs20 {Test Your Understanding
\par }\pard\plain \nowidctlpar\adjustright \f1 {\b\fs20 
\par }\pard\plain \s15\nowidctlpar\adjustright \f1\fs20 {
\par {\pntext\pard\plain\s15 \f1\fs20 \hich\af1\dbch\af0\loch\f1 1.\tab}}\pard \s15\fi-360\li360\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls8\adjustright {
Are all BRexx external functions available under all operating systems?  Which libraries are limited to which platforms?
\par }\pard \s15\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {
\par {\pntext\pard\plain\s15 \f1\fs20 \hich\af1\dbch\af0\loch\f1 2.\tab}}\pard \s15\fi-360\li360\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls8\adjustright {
Do BRexx external functions for 32-bit DOS work under Windows?
\par }\pard \s15\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {
\par {\pntext\pard\plain\s15 \f1\fs20 \hich\af1\dbch\af0\loch\f1 3.\tab}}\pard \s15\fi-360\li360\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls8\adjustright {
How do you position a file pointer within a BRex
x script?  How do you determine what the position of the current file pointer is?  How do you position the file pointer to the beginning of a file?   At the end of the file?  How can you determine the size of a file?  
\par }\pard \s15\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {
\par {\pntext\pard\plain\s15 \f1\fs20 \hich\af1\dbch\af0\loch\f1 4.\tab}}\pard \s15\fi-360\li360\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls8\adjustright {What are the ANSI functions for:

\par }\pard \s15\nowidctlpar\adjustright {
\par {\pntext\pard\plain\s15 \fs20 \hich\af0\dbch\af0\loch\f0 -\tab}}\pard \s15\fi-360\li1080\nowidctlpar\jclisttab\tx1080{\*\pn \pnlvlblt\ilvl0\ls9\pnrnot0\pnstart4\pnindent1080\pnhang{\pntxtb -}}\ls9\adjustright {Setting the video mode
\par {\pntext\pard\plain\s15 \fs20 \hich\af0\dbch\af0\loch\f0 -\tab}}\pard \s15\fi-360\li1080\nowidctlpar\jclisttab\tx1080{\*\pn \pnlvlblt\ilvl0\ls9\pnrnot0\pnstart4\pnindent1080\pnhang{\pntxtb -}}\ls9\adjustright {Saving and restoring cursor position
\par {\pntext\pard\plain\s15 \fs20 \hich\af0\dbch\af0\loch\f0 -\tab}}\pard \s15\fi-360\li1080\nowidctlpar\jclisttab\tx1080{\*\pn \pnlvlblt\ilvl0\ls9\pnrnot0\pnstart4\pnindent1080\pnhang{\pntxtb -}}\ls9\adjustright {
Moving the cursor to a specific x, y coordinate
\par {\pntext\pard\plain\s15 \fs20 \hich\af0\dbch\af0\loch\f0 -\tab}}\pard \s15\fi-360\li1080\nowidctlpar\jclisttab\tx1080{\*\pn \pnlvlblt\ilvl0\ls9\pnrnot0\pnstart4\pnindent1080\pnhang{\pntxtb -}}\ls9\adjustright {Setting the text attributes
\par {\pntext\pard\plain\s15 \fs20 \hich\af0\dbch\af0\loch\f0 -\tab}}\pard \s15\fi-360\li1080\nowidctlpar\jclisttab\tx1080{\*\pn \pnlvlblt\ilvl0\ls9\pnrnot0\pnstart4\pnindent1080\pnhang{\pntxtb -}}\ls9\adjustright {
Setting the foreground and background screen colors
\par }\pard \s15\nowidctlpar\adjustright {
\par {\pntext\pard\plain\s15 \f1\fs20 \hich\af1\dbch\af0\loch\f1 5.\tab}}\pard \s15\fi-360\li360\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls8\adjustright {
Where are file handles encoded in the C-like I/O functions?  Are file handles different from stream names in standard Rexx?
\par }\pard \s15\nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {
\par {\pntext\pard\plain\s15 \f1\fs20 \hich\af1\dbch\af0\loch\f1 6.\tab}}\pard \s15\fi-360\li360\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls8\adjustright {
What is the purpose of the EBCDIC functions?  Which function library would you use to perform \ldblquote date arithmetic\rdblquote ?
\par }\pard \s15\nowidctlpar\adjustright {
\par 
\par }\pard\plain \s4\keepn\nowidctlpar\outlinelevel3\adjustright \b\i\f1\fs20 {Programming Problems
\par }\pard\plain \nowidctlpar\adjustright \f1 {\b\fs20 
\par {\pntext\pard\plain\f1\fs20 \hich\af1\dbch\af0\loch\f1 1.\tab}}\pard \fi-360\li360\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls7\adjustright {\fs20 
Write a program that displays a full-screen menu using the ANSI terminal emulation functions.   The menu should provide the options Add, Insert, Delete and Exit.  The options themselves can be \ldblquote dummied out,\rdblquote  similar to the }{\b\fs20 
Menu}{\fs20  script example of chapter 3.   The display screen should have a centered heading, in boldface, with each menu option appearing in a different color.
\par }\pard \nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\fs20 
\par {\pntext\pard\plain\f1\fs20 \hich\af1\dbch\af0\loch\f1 2.\tab}}\pard \fi-360\li360\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls7\adjustright {\fs20 
Does your operating system allow you to replace the ANSI screen I/O functions with the Console I/O functions?  If it does, revise your menu program to use Console I/O.
\par }\pard \nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\fs20 
\par {\pntext\pard\plain\f1\fs20 \hich\af1\dbch\af0\loch\f1 3.\tab}}\pard \fi-360\li360\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls7\adjustright {\fs20 Write a program that sequent
ially assigns student ID numbers and writes student records to direct-access disk.  Write a corresponding script that retrieves student information based on the ID number.
\par }\pard \nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\fs20 
\par {\pntext\pard\plain\f1\fs20 \hich\af1\dbch\af0\loch\f1 4.\tab}}\pard \fi-360\li360\nowidctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec\pnstart1\pnindent360\pnhang{\pntxta .}}\ls7\adjustright {\fs20 If you use any version of DOS, write a 
\ldblquote system information\rdblquote  program that finds out everything it can about the PC on which it runs.
\par }\pard \nowidctlpar\adjustright {\fs20 
\par \page }{\i\fs20 Figure 21-1   The Pool Pass System Data Entry Screen
\par }{\fs20 
\par 
\par The data-entry script that assigns Swimming Pool Passes clears the screen.  Then it displays a form similar to the one below, with bright cyan letters on a dark blue background:
\par 
\par }{\fs20\cf2          
\par }{\b\fs20\cf2 +---------------------------------------------------------------------------------------------------------------------------+}{\b\fs20\cf2\sub 
\par }\pard\plain \s5\keepn\nowidctlpar\outlinelevel4\adjustright \b\f1\fs20\cf2 {|                                                            Pool Pass System                                                          |
\par }\pard\plain \nowidctlpar\adjustright \f1 {\b\fs20\cf2 |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |  First   Name: __________\tab \tab \tab \tab \tab \tab \tab \tab         |
\par |  Last   Name: __________\tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |  Phone Number: ___-____\tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par }{\fs20\cf2 |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par }{\b\fs20\cf2 +---------------------------------------------------------------------------------------------------------------------------+}{\b\fs20\cf2\sub 
\par }{\fs20 
\par 
\par }{\i\fs20 
\par Figure 21-2}{\fs20  }{\i\fs20   The Data Entry Screen After Data Entry}{\fs20 
\par 
\par }{\fs20\cf2 
\par }\pard\plain \s15\nowidctlpar\adjustright \f1\fs20 {Here\rquote s how the data entry screen might appear after the user has entered data for a pool patron:
\par }\pard\plain \nowidctlpar\adjustright \f1 {\fs20\cf2 
\par 
\par }{\b\fs20\cf2 +---------------------------------------------------------------------------------------------------------------------------+}{\b\fs20\cf2\sub 
\par }\pard\plain \s5\keepn\nowidctlpar\outlinelevel4\adjustright \b\f1\fs20\cf2 {|                                                            Pool Pass System                                                          |
\par }\pard\plain \nowidctlpar\adjustright \f1 {\b\fs20\cf2 |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |  First   Name: Monica___\tab \tab \tab \tab \tab \tab \tab \tab         |
\par |  Last   Name: Geller____\tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |  Phone Number: 476-4243_\tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par }{\fs20\cf2 |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab  \tab         |
\par |\tab \tab \tab \tab \tab \tab \tab \tab \tab \tab \tab         |
\par }{\b\fs20\cf2 +---------------------------------------------------------------------------------------------------------------------------+}{\b\fs20\cf2\sub 
\par }{\fs20 
\par }}